# ======================================================================================
# Title: Robust NAIP Download, Mosaic, Reprojection, and Tiled Clipping Pipeline (GA)
# Description:
#   - Generates 10x10 tile grid over Georgia and saves as shapefile
#   - Downloads NAIP imagery using STAC API with retry and timeout handling
#   - Reprojects all inputs to target CRS (EPSG:26916) if needed
#   - Mosaics and clips imagery per tile geometry (even with partial coverage)
#   - Parallelized for efficient processing
# Author: Faraz Gorgin
# Date: July 2025 
# ======================================================================================

import os
import glob
import time
import requests
import numpy as np
import geopandas as gpd
from shapely.geometry import box, mapping
import rasterio
from rasterio.merge import merge
from rasterio.mask import mask
from rasterio.warp import calculate_default_transform, reproject, Resampling
from pystac_client import Client
from planetary_computer import sign
from multiprocessing import Pool
from tqdm import tqdm
import traceback

# === CONFIGURATION ===
year = 2017
target_crs = "EPSG:26916"
max_retries = 5
num_workers = 10
base_dir = "/icebox/data/shares/mh1/fgorginpaveh/Georgia"
tile_shapefile = os.path.join(base_dir, "GA_100_tiles.shp")

# === STEP 1: Create Tiles for Georgia (only runs once if shapefile doesn't exist)
if not os.path.exists(tile_shapefile):
    print("üß± Creating tile grid for Georgia...")
    us_shapefile = "/icebox/data/shares/mh1/fgorginpaveh/US shapefile/tl_2024_us_state.shp"
    states = gpd.read_file(us_shapefile).to_crs("EPSG:4326")

    georgia = states[states['NAME'].str.lower() == 'georgia']
    if georgia.empty:
        raise ValueError("Georgia not found in shapefile.")

    ga_geom = georgia.geometry.values[0]
    ga_bounds = ga_geom.bounds  # (minx, miny, maxx, maxy)

    # === Generate 10x10 grid
    minx, miny, maxx, maxy = ga_bounds
    rows, cols = 10, 10
    width = (maxx - minx) / cols
    height = (maxy - miny) / rows

    tiles = []
    for i in range(rows):
        for j in range(cols):
            x1 = minx + j * width
            y1 = miny + i * height
            x2 = x1 + width
            y2 = y1 + height
            tile = box(x1, y1, x2, y2)
            tiles.append(tile)

    tiles_gdf = gpd.GeoDataFrame(geometry=tiles, crs="EPSG:4326")
    tiles_clipped = gpd.overlay(tiles_gdf, georgia, how="intersection")

    tiles_clipped["row"] = np.repeat(np.arange(rows), cols)[:len(tiles_clipped)]
    tiles_clipped["col"] = np.tile(np.arange(cols), rows)[:len(tiles_clipped)]
    tiles_clipped["tile_id"] = ["tile_%02d_%02d" % (r, c) for r, c in zip(tiles_clipped["row"], tiles_clipped["col"])]

    os.makedirs(os.path.dirname(tile_shapefile), exist_ok=True)
    tiles_clipped.to_file(tile_shapefile)

    print(f"‚úÖ Done. 100 tiles covering Georgia saved to:\n{tile_shapefile}")

# === STEP 2: Load Tile Geometries
tiles_gdf = gpd.read_file(tile_shapefile)

# === Helper: Retry download
def download_with_retry(url, out_fp, max_retries=5):
    for attempt in range(max_retries):
        try:
            with requests.get(url, stream=True, timeout=180) as r:
                r.raise_for_status()
                with open(out_fp, "wb") as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Download attempt {attempt+1} failed: {e}")
            time.sleep(5 * (attempt + 1))  # exponential backoff
    return False

# === Helper: Retry STAC query
def query_stac_with_retry(geom):
    for attempt in range(max_retries):
        try:
            client = Client.open("https://planetarycomputer.microsoft.com/api/stac/v1", timeout=180)
            search = client.search(
                collections=["naip"],
                intersects=geom.__geo_interface__,
                datetime=f"{year}-01-01/{year}-12-31",
                limit=100
            )
            return list(search.items())
        except Exception as e:
            print(f"‚ö†Ô∏è STAC attempt {attempt+1} failed: {e}")
            time.sleep(5 * (attempt + 1))
    return []

def process_tile(tile_id):
    try:
        print(f"\nüöÄ Starting {tile_id}")
        download_dir = os.path.join(base_dir, f"{tile_id}_Images")
        output_dir = os.path.join(base_dir, f"{tile_id}_Output")
        os.makedirs(download_dir, exist_ok=True)
        os.makedirs(output_dir, exist_ok=True)
        output_fp = os.path.join(output_dir, f"{tile_id}_mosaic_clipped.tif")
        if os.path.exists(output_fp):
            print(f"‚úÖ Already exists: {output_fp}")
            return

        tile_4326 = tiles_gdf[tiles_gdf["tile_id"] == tile_id].to_crs("EPSG:4326")
        tile_utm = tiles_gdf[tiles_gdf["tile_id"] == tile_id].to_crs(target_crs)
        if tile_4326.empty or tile_utm.empty:
            print(f"‚ùå Geometry not found for {tile_id}")
            return

        geom_4326 = tile_4326.iloc[0].geometry
        geom_utm = tile_utm.iloc[0].geometry
        geom_bounds = geom_utm.bounds
        geom_mask = [mapping(geom_utm)]

        items = query_stac_with_retry(geom_4326)
        if not items:
            print(f"‚ùå No images found for {tile_id}")
            return

        # === Download images
        tif_files = []
        for item in items:
            signed = sign(item)
            url = signed.assets["image"].href
            out_fp = os.path.join(download_dir, f"{item.id}.tif")
            if not os.path.exists(out_fp):
                success = download_with_retry(url, out_fp, max_retries)
                if not success:
                    print(f"‚ùå Failed to download after retries: {item.id}")
                    continue
            tif_files.append(out_fp)

        if not tif_files:
            print(f"‚ùå No TIFFs downloaded for {tile_id}")
            return

        # === Reproject if needed
        mosaic_sources = []
        temp_files = []
        for fp in tif_files:
            with rasterio.open(fp) as src:
                if not src.crs or src.crs.to_string() != target_crs:
                    reproj_fp = os.path.join(download_dir, f"{os.path.basename(fp)}_reproj.tif")
                    dst_transform, width, height = calculate_default_transform(
                        src.crs, target_crs, src.width, src.height, *src.bounds
                    )
                    dst_meta = src.meta.copy()
                    dst_meta.update({
                        "crs": target_crs,
                        "transform": dst_transform,
                        "width": width,
                        "height": height,
                        "nodata": src.nodata
                    })
                    with rasterio.open(reproj_fp, "w", **dst_meta) as dst:
                        for i in range(1, src.count + 1):
                            reproject(
                                source=rasterio.band(src, i),
                                destination=rasterio.band(dst, i),
                                src_transform=src.transform,
                                src_crs=src.crs,
                                dst_transform=dst_transform,
                                dst_crs=target_crs,
                                resampling=Resampling.bilinear
                            )
                    mosaic_sources.append(reproj_fp)
                    temp_files.append(reproj_fp)
                else:
                    mosaic_sources.append(fp)

        # === Mosaic and Clip
        srcs = [rasterio.open(fp) for fp in mosaic_sources]
        mosaic, mosaic_transform = merge(srcs, bounds=geom_bounds)
        out_meta = srcs[0].meta.copy()
        out_meta.update({
            "height": mosaic.shape[1],
            "width": mosaic.shape[2],
            "transform": mosaic_transform,
            "crs": target_crs,
            "nodata": 0
        })
        for s in srcs: s.close()

        with rasterio.open("/vsimem/temp_mosaic.tif", "w", **out_meta) as temp_ds:
            temp_ds.write(mosaic)

        with rasterio.open("/vsimem/temp_mosaic.tif") as temp_src:
            out_image, out_transform = mask(temp_src, shapes=geom_mask, crop=True, nodata=0)
            out_meta.update({
                "height": out_image.shape[1],
                "width": out_image.shape[2],
                "transform": out_transform
            })

        with rasterio.open(output_fp, "w", **out_meta) as dst:
            dst.write(out_image)

        print(f"‚úÖ Saved: {output_fp}")

        for fp in temp_files:
            os.remove(fp)

    except Exception as e:
        print(f"‚ùå Error in {tile_id}:\n{traceback.format_exc()}")

# === MAIN
def main():
    tile_ids = tiles_gdf["tile_id"].tolist()
    with Pool(num_workers) as pool:
        list(tqdm(pool.imap(process_tile, tile_ids), total=len(tile_ids)))

if __name__ == "__main__":
    main()
